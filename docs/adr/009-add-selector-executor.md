### **ADR-009: 引入 `SelectorExecutor` 并实施交互规范化以实现终极职责分离**

**状态：** 已接受 (Accepted)

**日期：** 2025-11-10

#### **背景 (Context)**

在 `ADR-008` 引入 `InteractionStore` 之后，我们虽然为“交互（边）”提供了一个中央仓库，但在实现过程中，我们发现了两个新的、更深层次的架构问题：

1.  **选择器逻辑的知识泄露与分散：** `InteractionStore` 和 `IDMapper` 为了支持声明式查询，被迫需要理解 `SelectorConfig` 的内部结构并实现复杂的匹配逻辑。这污染了它们作为“纯粹数据存储”的核心职责，并且导致匹配逻辑（特别是复杂的双向匹配）分散在多个模块中，难以维护且极易出错（正如反复失败的单元测试所证明的）。

2.  **双向匹配的固有复杂性：** 系统下游的所有查询服务（`SelectorExecutor`, `Sampler`, `Splitter`）都必须处理“正向匹配”和“反向匹配”的复杂组合，这不仅增加了代码量和认知负担，也成为了 bug 的温床。这本质上是因为我们的数据存储范式（忠实记录原始方向）与我们的应用需求（主要处理无向图）之间存在不匹配。

为了追求架构的极致清晰、健壮和高效，我们需要对查询逻辑和数据范式进行一次根本性的重构。

#### **决策 (Decision)**

我们将实施两大核心决策，共同构成一个职责分离的三层架构（**存储层-逻辑层-策略层**）：

**决策一：引入 `SelectorExecutor` 作为独立的逻辑层**

我们将创建一个新的、无状态的服务 `SelectorExecutor`。它的**唯一职责**是作为“选择器解释与执行引擎”，封装所有与“如何根据`SelectorConfig`匹配数据”相关的逻辑。

- **职责转移：** 所有与选择器匹配相关的代码（`_entity_meta_matches_selector`, `_get_match_mask`等）将从`InteractionStore`中**完全移除**，并迁移到`SelectorExecutor`中。
- **依赖注入：** `SelectorExecutor`在初始化时接收`IDMapper`作为依赖，以便获取实体元数据。所有需要执行选择器逻辑的上层服务（如`InteractionStore`的`query`方法）将在内部实例化并调用`SelectorExecutor`。
- **结果：** `InteractionStore`和`IDMapper`被净化为纯粹的**存储层**，它们不再需要理解`SelectorConfig`的复杂结构。

**决策二：在 `InteractionStore` 中实施交互规范化**

我们将改变`InteractionStore`的核心数据范式，从“忠实记录方向”演进为**“规范化单向存储”**。

- **初始化即规范化：** 在`InteractionStore`的`__init__`方法中，将增加一个`_canonicalize_pairs`步骤。该步骤会遍历所有原始交互，并根据一套在`knowledge_graph.py`中定义的、基于实体类型优先级的**全局排序规则**，按需交换`source`和`target`列的内容。
  - **异质交互 (如 DTI):** 总是将优先级高的实体类型（如 `drug`）放在`source`列。
  - **同质交互 (如 PPI):** 总是将 ID 字典序较小的实体放在`source`列，这天然地实现了去重。
- **下游逻辑简化：** 由于`InteractionStore`中的所有数据现在都是规范化的、单向的，`SelectorExecutor`内部的匹配逻辑将**被极度简化**。所有与“反向匹配”（`match_backward`）相关的复杂代码将被**彻底删除**。查询逻辑将退化为简单、高效、不易出错的单向匹配。

#### **备选方案 (Considered Options)**

**1. 仅引入 `SelectorExecutor`，保留双向匹配**

- **方案描述：** 只执行决策一，将双向匹配的复杂逻辑封装在`SelectorExecutor`中，但`InteractionStore`仍然存储原始方向的数据。
- **优点：** 实现了逻辑内聚，`InteractionStore`被净化。
- **缺点：** 系统的核心复杂性（双向匹配）只是被“隐藏”在了`SelectorExecutor`中，并没有被消除。查询性能和代码健壮性的根本问题依然存在。
- **决策理由：** 这只解决了问题的一半。既然我们的核心应用场景是无向图，就应该从数据范式上根除双向匹配的必要性，而不是仅仅将其封装起来。

**2. 仅实施交互规范化，不引入 `SelectorExecutor`**

- **方案描述：** 只执行决策二，在`InteractionStore`中规范化数据，然后简化其内部的`query`方法。
- **优点：** 移除了双向匹配的复杂性。
- **缺点：** `InteractionStore`仍然承担着“存储”和“解释选择器”两种不同的职责，违反了单一职责原则。知识泄露问题依然存在。
- **决策理由：** 职责分离是更高级的架构追求。将选择器执行逻辑独立出来，能最大化系统的模块化和未来的可扩展性。

#### **后果 (Consequences)**

**正面影响：**

- **形成了完美的“三层架构”：**
  - **存储层 (`IDMapper`, `InteractionStore`)**: 纯粹，只负责存储和基础检索。
  - **逻辑层 (`SelectorExecutor`)**: 内聚，是唯一理解“查询语言”的地方。
  - **策略/编排层 (`Sampler`, `Splitter`)**: 简洁，只负责调用逻辑层来执行业务策略。
- **代码的终极简化与健壮性：** 通过消除双向匹配，`SelectorExecutor`的核心逻辑变得极其简单、清晰，几乎不可能出错。这从根本上解决了我们反复遇到的 bug。
- **性能提升：** 所有查询的计算量减半。
- **概念模型的清晰：** 系统的每一个核心组件现在都有一个极其明确、单一的职责，极大地降低了新成员理解和维护系统的认知负担。

**负面影响/权衡：**

- **丧失原始方向信息：** 这是一个经过深思熟虑后主动做出的权衡。我们判断，对于当前和可预见的未来（无向图链接预测），保留原始方向信息的价值，远低于其带来的巨大复杂性成本。
- **增加了一个新模块 (`SelectorExecutor`)：** 这是良性的复杂性增加，因为它通过引入一个新模块，换取了多个现有模块的简化和整个系统清晰度的提升。

---

**关联的 ADR**

- **精炼 (Refines)**: 本 ADR 精炼了`ADR-008`的设计，通过引入`SelectorExecutor`进一步净化了`InteractionStore`的职责。
- **应用 (Applies)**: 本 ADR 是`ADR-007`（引入选择器）的最终实现范式，它定义了选择器将如何被一个独立的逻辑层来执行。
